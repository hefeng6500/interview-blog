# 198.打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
  偷窃到的最高金额 = 1 + 3 = 4
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
    偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

提示：

- 1 <= nums.length <= 100
- 0 <= nums[i] <= 400

### 解法

**1、动态规划**

- 确定状态
- 递推公式
- 确定初始条件和边界条件
- 计算结果

**确定状态：**

设置二维数组 `dp[length][0 or 1]`，第一维度：第 i 家；第二维度：`0` 没偷，`1` 偷了

设置 `dp[i][0]` 表示第 `i + 1` 家没偷时的最大总金额(为什么 `i+1`, 因为下标从 `0` 开始)
设置 `dp[i][i]` 表示第 `i + 1` 家被偷了的最大总金额

**递推公式：**

```js
dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
```

第 i + 1 家没偷时，i 家可以偷或者没偷，求最大值即可\*

```js
dp[i][1] = dp[i - 1][0] + nums[i];
```

第 i + 1 家被偷时，i 家必须是没偷，求 i 家被偷和 i + 1 的总和即可

**确定初始条件和边界条件**

```js
dp[0][0] = 0; // 第 1 家没偷时， 最大金额为 0
dp[0][1] = nums[0]; // 第 1 家被偷就是 nums[0]
```

**计算结果**

```js
// 求最后一家偷或没偷的最大值
Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
  let dp = [[0, nums[0]]];

  for (let i = 1; i < nums.length; i++) {
    dp[i] = dp[i] || [];

    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
    dp[i][1] = dp[i - 1][0] + nums[i];
  }

  return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
};
```

上述逻辑使用了二维数组，其实我们只需要前一家偷或没偷的值即可，再往前面的值就不需要，所以我们 **优化一下算法空间复杂度**

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
  let dp0 = 0;
  let dp1 = nums[0];

  for (let i = 1; i < nums.length; i++) {
    // 防止dp0被修改之后对下面运算造成影响，
    // 这里使用一个临时变量temp先把结果存起来，计算完之后再赋值给dp0.
    const temp = Math.max(dp0, dp1);
    dp1 = dp0 + nums[i];
    dp0 = temp;
  }

  return Math.max(dp0, dp1);
};
```
